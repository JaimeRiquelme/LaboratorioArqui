.data
    Aporx: .asciiz "La aproximacion es : "
    random_msg: .asciiz " Codenada X aleatoria entre 0 y 100 : "
    random_msg2: .asciiz " Cordenada Y aleatoria entre 0 y 100 : "
    valor: .float 4.0
    iterations: .word 12  # Definimos el número de iteraciones
    count:      .word 0    # Contador de iteraciones
    init_val:   .float 1.0
    two:        .float 2.0
    cien:   	  .float 100.0
	
.text

main:
	li $s0, 1000
	l.s $f5 , cien
	li $s7, 1
	li $s6, 0
	li $s5, 0
	lw $t8, count
       lw $t9, iterations
       l.s $f16, init_val


GenerarPuntoAleatorio:

    slt $t6,$s6,$s0
    beq $t6, $zero, division
    add $s6,$s6,$s7
    
    # Generar primer número aleatorio
    li $a1 , 101
    li $v0, 42
    syscall

    # Guardar el primer número aleatorio en $t0
    mtc1 $a0, $f11
    cvt.s.w $f11, $f11
    
  
    # Generar segundo número aleatorio
    li $a1 , 101
    li $v0, 42
    syscall

    # Guardar el segundo número aleatorio en $t1
    mtc1 $a0, $f12
    cvt.s.w $f12, $f12
   
    
PuntoDentroDelCirculo:
    jal CalcularDistancia
    # Comparar los valores en los registros de punto flotante
    c.lt.s $f16, $f5       # Comparar $f16 < $f5
    bc1t Contador          # Si la comparación es verdadera (f16 < f5), saltar a "Contador"  
    # Si la comparación no es verdadera (f16 >= f5), seguir abajo del código
    j GenerarPuntoAleatorio


Contador:
	add $s5,$s5,$s7
	J GenerarPuntoAleatorio
	
	


CalcularDistancia:
  # Calculamos el cuadrado de x
  mul.s $f13, $f11, $f11  # $t2 = x^2

  # Calculamos el cuadrado de y
  mul.s $f14, $f12, $f12  # $t3 = y^2

  # Sumamos los cuadrados de x y y
  add.s $f15, $f13, $f14  # $t4 = x^2 + y^2
  li $t8, 0
  J Raiz
  
volver:
  jr $ra  # Saltamos de regreso a la rutina de llamada+
  
division:
    move $t0, $s5    # Cargar el primer número entero en $t0
    move $t1, $s6   # Cargar el segundo número entero en $t1

    # Convertir los valores enteros a punto flotante
    mtc1 $t0, $f0    # Mover el valor de $t0 a $f0
    cvt.s.w $f0, $f0 # Convertir el valor de entero a punto flotante en $f0
    mtc1 $t1, $f1    # Mover el valor de $t1 a $f1
    cvt.s.w $f1, $f1 # Convertir el valor de entero a punto flotante en $f1

    # Realizar la división de coma flotante
    div.s $f2, $f0, $f1   # Dividir $f0 por $f1 y guardar el resultado en $f2
   
   
Multiplicacion:
    lwc1 $f12, valor  # Load 4.0 into $f12
    mul.s $f0, $f2, $f12  # Multiply $f2 by 4.0, store result in $f0
    j fin


Raiz:
    bge $t8, $t9, volver  # Si hemos alcanzado el número de iteraciones, terminamos

    # Realizamos la división de n ($f1) con Xi ($f2)
    div.s $f17, $f15, $f16

    # Sumamos el resultado de la división ($f3) con Xi ($f2)
    add.s $f18, $f17, $f16

    # Dividimos ese resultado por 2.0
    l.s $f19, two
    div.s $f20, $f18, $f19

    # Movemos el resultado final a $f2 para la próxima iteración
    mov.s $f16, $f20

    # Incrementamos el contador de iteraciones
    addiu $t8, $t8, 1
    sw $t8, count

    # Volvemos a la etiqueta Raiz para continuar con las iteraciones
    j Raiz



fin:
    mov.s $f12, $f0  # Move the float from $f0 to $f12
    li $v0, 2  # Set the system call code for print_float
    syscall  # Make the system call

    li $v0, 10  # Set the system call code for exit
    syscall  # Make the system call


    
 


