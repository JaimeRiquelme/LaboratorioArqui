.data
    Aporx: .asciiz "La aproximacion es : "     # Un mensaje de salida
    random_msg: .asciiz " Codenada X aleatoria entre 0 y 100 : "  # Otro mensaje de salida
    random_msg2: .asciiz " Cordenada Y aleatoria entre 0 y 100 : " # Y otro mensaje de salida
    valor: .float 4.0   # Un valor de coma flotante para la multiplicación
    iterations: .word 12  # Número de iteraciones
    count: .word 0  # Contador inicializado a 0
    init_val: .float 1.0  # Valor inicial para la raíz cuadrada
    two: .float 2.0  # Valor flotante 2.0
    cien: .float 100.0 # Valor flotante 100.0

.text

main:
    li $s0, 1000   # Define el número de puntos aleatorios a generar
    l.s $f5 , cien   # Carga el valor de cien en el registro de coma flotante $f5
    li $s7, 1   # Valor 1 para incrementos
    li $s6, 0   # Contador de puntos generados
    li $s5, 0   # Contador de puntos dentro del círculo
    lw $t8, count   # Carga el valor de count en $t8
    lw $t9, iterations  # Carga el valor de iterations en $t9
    l.s $f16, init_val   # Carga el valor de init_val en $f16

GenerarPuntoAleatorio:
    slt $t6,$s6,$s0   # Verifica si se han generado todos los puntos necesarios
    beq $t6, $zero, FinDelBucle   # Si ya se han generado todos los puntos, salta a FinDelBucle
    add $s6,$s6,$s7   # Incrementa el contador de puntos generados
    jal GenerarNumerosAleatorios   # Genera dos números aleatorios para x e y
    jal CalcularDistancia  # Calcula la distancia de (x, y) al origen
    c.lt.s $f16, $f5  # Verifica si el punto está dentro del círculo
    bc1t Contador   # Si el punto está dentro del círculo, incrementa el contador de puntos dentro del círculo
    j GenerarPuntoAleatorio   # Si el punto no está dentro del círculo, genera un nuevo punto

Contador:
    add $s5,$s5,$s7   # Incrementa el contador de puntos dentro del círculo
    j GenerarPuntoAleatorio   # Genera un nuevo punto

FinDelBucle:
    jal Dividir   # Divide el número de puntos dentro del círculo por el número total de puntos
    jal Multiplicar  # Multiplica el resultado de la división por 4
    j fin   # Salta al final del programa


GenerarNumerosAleatorios:
    li $a1 , 101  # Define el rango del número aleatorio
    li $v0, 42   # Define el c++ódigo de syscall para generar un número aleatorio
    syscall   # Genera un número aleatorio
    mtc1 $a0, $f11  # Mueve el número aleatorio al registro de coma flotante $f11
    cvt.s.w $f11, $f11  # Convierte el número aleatorio a coma flotante

    li $a1 , 101  # Define el rango del número aleatorio
    li $v0, 42   # Define el código de syscall para generar un número aleatorio
    syscall   # Genera un número aleatorio
    mtc1 $a0, $f12  # Mueve el número aleatorio al registro de coma flotante $f12
    cvt.s.w $f12, $f12  # Convierte el número aleatorio a coma flotante
    jr $ra   # Retorna al lugar de donde fue llamada la función


CalcularDistancia:
    mul.s $f13, $f11, $f11  # Calcula el cuadrado de la coordenada x
    mul.s $f14, $f12, $f12  # Calcula el cuadrado de la coordenada y
    add.s $f15, $f13, $f14  # Suma los cuadrados de las coordenadas x e y
    li $t8, 0   # Inicializa $t8 a 0
    
    addiu $sp, $sp, -4  # Reduce el puntero de la pila en 4 para guardar el valor de $ra
    sw $ra, 0($sp)   # Guarda el valor de $ra en la pila
    
    
    jal Raiz   # Calcula la raíz cuadrada de $f15
    
    lw $ra, 0($sp)  # Recupera el valor de $ra de la pila
    addiu $sp, $sp, 4   # Incrementa el puntero de la pila en 4

    jr $ra  # Retorna al lugar de donde fue llamada la función


Raiz:
    bge $t8, $t9, volver   # Si se han realizado todas las iteraciones, retorna al lugar de donde fue llamada la función
    div.s $f17, $f15, $f16  # Divide $f15 por $f16
    add.s $f18, $f17, $f16  # Suma $f17 y $f16
    l.s $f19, two   # Carga el valor de two en $f19
    div.s $f20, $f18, $f19  # Divide $f18 por $f19
    mov.s $f16, $f20  # Mueve el valor de $f20 a $f16
    addiu $t8, $t8, 1  # Incrementa $t8
    sw $t8, count  # Guarda el valor de $t8 en count
    j Raiz   # Salta a la parte superior de la función

volver:
    jr $ra   # Retorna al lugar de donde fue llamada la función


Dividir:
    move $t0, $s5   # Mueve el valor de $s5 a $t0
    move $t1, $s6   # Mueve el valor de $s6 a $t1
    mtc1 $t0, $f0   # Mueve el valor de $t0 al registro de coma flotante $f0
    cvt.s.w $f0, $f0   # Convierte el valor de $f0 a coma flotante
    mtc1 $t1, $f1   # Mueve el valor de $t1 al registro de coma flotante $f1
    cvt.s.w $f1, $f1   # Convierte el valor de $f1 a coma flotante
    div.s $f2, $f0, $f1  # Divide $f0 por $f1
    jr $ra   # Retorna al lugar de donde fue llamada la función


Multiplicar:
    lwc1 $f12, valor  # Carga el valor de valor en $f12
    mul.s $f0, $f2, $f12  # Multiplica $f2 por $f12
    jr $ra  # Retorna al lugar de donde fue llamada la función


fin:
    mov.s $f12, $f0  # Mueve el valor de $f0 a $f12
    li $v0, 2   # Define el código de syscall para imprimir un número de coma flotante
    syscall  # Imprime el número de coma flotante
    li $v0, 10  # Define el código de syscall para terminar la ejecución del programa
    syscall  # Termina la ejecución del programa

